"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = exports.builder = exports.desc = exports.command = void 0;
const config_1 = require("./../helpers/config");
const ora_1 = __importDefault(require("ora"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const build_1 = require("../helpers/build");
const exit_1 = require("../helpers/exit");
const api_1 = require("../api");
const helpers_1 = require("../helpers");
const Sentry = __importStar(require("@sentry/node"));
const waitAllProcessingStories_1 = require("../helpers/waitAllProcessingStories");
const constants_1 = require("../constants");
const s3_1 = require("../helpers/s3");
exports.command = 'sync';
exports.desc = 'Sync Storybook to Figma using Anima';
const builder = (yargs) => yargs
    .options({
    token: { type: 'string', alias: 't' },
    directory: { type: 'string', alias: 'd' },
    basePath: { type: 'string', alias: 'b' },
    designTokens: { type: 'string' },
    debug: { type: 'boolean' },
})
    .example([['$0 sync -t <storybook-token> -d <build-directory>']]);
exports.builder = builder;
const handler = async (_argv) => {
    const transaction = Sentry.startTransaction({
        op: 'start-sync',
        name: 'start sync process',
    });
    Sentry.getCurrentHub().configureScope((scope) => scope.setSpan(transaction));
    const __DEBUG__ = !!_argv.debug;
    const animaConfig = await (0, config_1.loadAnimaConfig)();
    let stage = 'Checking local environment';
    let loader = (0, ora_1.default)(`${stage}...\n`).start();
    // check if token is provided as an arg or in .env
    const token = (_argv.token ??
        process.env.STORYBOOK_ANIMA_TOKEN ??
        '');
    if (__DEBUG__) {
        console.log('token =>', token);
    }
    if (!token) {
        loader.stop();
        helpers_1.log.yellow(`Storybook token not found. Please provide a token using the --token flag or the STORYBOOK_ANIMA_TOKEN environment variable.`);
        await (0, exit_1.exitProcess)();
    }
    // check if build directory exists
    let BUILD_DIR;
    if (_argv.directory && (0, s3_1.isS3Url)(_argv.directory)) {
        console.log('Using s3 url, creating tmp dir');
        (0, s3_1.setUsingS3Url)(true);
        await (0, s3_1.downloadFromUrl)(_argv.directory, constants_1.TMP_DIR);
        BUILD_DIR = constants_1.TMP_DIR;
    }
    else {
        BUILD_DIR = (0, build_1.getBuildDir)(_argv.directory);
    }
    if (!fs_extra_1.default.existsSync(BUILD_DIR)) {
        loader.stop();
        helpers_1.log.yellow(`Cannot find build directory: "${_argv.directory ?? build_1.DEFAULT_BUILD_DIR}". Please build storybook before running this command `);
        Sentry.captureException(new Error('Cannot find build directory'));
        transaction.status = 'error';
        transaction.finish();
        await (0, exit_1.exitProcess)();
    }
    const authSpan = transaction.startChild({ op: 'authenticate' });
    // validate token with the api
    const response = await (0, api_1.authenticate)(token);
    loader.stop();
    if (!response.success) {
        helpers_1.log.red(`The Storybook token you provided "${token}" is invalid. Please check your token and try again.`);
        Sentry.captureException(new Error("The Storybook token you provided 'HIDDEN' is invalid. Please check your token and try again."));
        authSpan.status = 'error';
        authSpan.finish();
        transaction.finish();
        await (0, exit_1.exitProcess)();
    }
    Sentry.configureScope((scope) => {
        scope.setUser({
            id: response.data.team_slug,
            team_id: response.data.team_id,
        });
        scope.setTag('teamId', response.data.team_id);
    });
    authSpan.finish();
    helpers_1.log.green(`  - ${stage} ...OK`);
    const spanZipBuild = transaction.startChild({ op: 'zip-build-and-hash' });
    // zip the build directory and create a hash
    stage = 'Preparing files';
    loader = (0, ora_1.default)(`${stage}...`).start();
    const zipBuffer = await (0, helpers_1.zipDir)(BUILD_DIR);
    const zipHash = (0, helpers_1.hashBuffer)(zipBuffer);
    __DEBUG__ && console.log('generated hash =>', zipHash);
    spanZipBuild.finish();
    loader.stop();
    helpers_1.log.green(`  - ${stage} ...OK`);
    const spanGetDSToken = transaction.startChild({ op: 'get-ds-token' });
    // create storybook object if no record with the same hash is found and upload it
    stage = 'Syncing files';
    loader = (0, ora_1.default)(`${stage}...`).start();
    let skipUpload = true;
    let designTokens = animaConfig.design_tokens ?? {};
    // check if design tokens json is provided and add it to the payload
    const designTokenFilePath = _argv.designTokens;
    try {
        if (designTokenFilePath) {
            if (fs_extra_1.default.existsSync(designTokenFilePath)) {
                designTokens = await fs_extra_1.default.readJSON(designTokenFilePath);
            }
            else {
                throw new Error('Path not found');
            }
        }
    }
    catch (error) {
        const errorMessage = `Fail to read design tokens at path "${designTokenFilePath}"`;
        loader.stop();
        helpers_1.log.yellow(errorMessage);
        Sentry.captureException(new Error("Fail to read design tokens at path 'HIDDEN'"));
        spanGetDSToken.status = 'error';
        spanGetDSToken.finish();
        transaction.finish();
        await (0, exit_1.exitProcess)();
    }
    spanGetDSToken.finish();
    const basePath = _argv.basePath;
    const data = await (0, api_1.getOrCreateStorybook)(token, zipHash, designTokens, basePath);
    const spanUpload = transaction.startChild({
        op: 'upload-process',
    });
    Sentry.getCurrentHub().configureScope((scope) => scope.setSpan(spanUpload));
    const { storybookId, uploadUrl } = data;
    const currentDesignTokenStr = data.designTokens;
    let { uploadStatus } = data;
    __DEBUG__ && console.log('storybookId =>', storybookId);
    if (uploadStatus !== 'complete' && uploadUrl && storybookId) {
        skipUpload = false;
        const uploadResponse = await (0, helpers_1.uploadBuffer)(uploadUrl, zipBuffer);
        const upload_status = uploadResponse.status === 200 ? 'complete' : 'failed';
        await (0, api_1.updateStorybook)(token, storybookId, {
            upload_status,
            preload_stories: true,
        });
        uploadStatus = upload_status;
    }
    if (storybookId && uploadStatus === 'complete') {
        await (0, api_1.updateDSTokenIfNeeded)({
            storybook: {
                id: storybookId,
                ds_tokens: currentDesignTokenStr,
                upload_status: uploadStatus,
            },
            token,
            currentDSToken: designTokens,
        }).catch((e) => {
            Sentry.captureException(e);
            helpers_1.log.yellow(`Fail to update designTokens, ${e.message}`);
        });
    }
    spanUpload.finish();
    loader.stop();
    stage = 'Processing stories';
    loader = (0, ora_1.default)(`${stage}...`).start();
    const waitProcessSpan = transaction.startChild({
        op: 'waitProcessingStories',
    });
    // --- Start wait sync
    await (0, waitAllProcessingStories_1.waitProcessingStories)(token, {
        onCheckStories: (stories) => {
            loader.stop();
            stage =
                stories.length > 0
                    ? `Processing stories: ${stories.length} remaining`
                    : 'Processing stories';
            loader = (0, ora_1.default)(`${stage}...`).start();
        },
    });
    loader.stop();
    waitProcessSpan.finish();
    // --- Cleaning and goodbye ---
    transaction.status = 'ok';
    transaction.finish();
    helpers_1.log.green(`  - ${stage} ...  ${skipUpload ? (__DEBUG__ ? 'SKIP' : 'OK') : 'OK'} `);
    helpers_1.log.green('  - Done');
    if ((0, s3_1.isUsingS3Url)()) {
        console.log('Cleaning tmp dir');
        fs_extra_1.default.rmSync(constants_1.TMP_DIR, { recursive: true, force: true });
    }
    if (__DEBUG__) {
        console.log('_id =>', storybookId);
        console.log('hash =>', zipHash);
    }
};
exports.handler = handler;
