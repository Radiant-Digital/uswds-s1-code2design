"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _StorybookApi_endpoint, _StorybookApi_addionalHeaders, _StorybookApi_getHeaders;
Object.defineProperty(exports, "__esModule", { value: true });
exports.StorybookApi = void 0;
const axios_1 = __importDefault(require("axios"));
const hash_1 = require("./hash");
class StorybookApi {
    constructor(opts) {
        _StorybookApi_endpoint.set(this, void 0);
        _StorybookApi_addionalHeaders.set(this, void 0);
        this.getStorybookByHash = async (token, hash) => {
            const res = await (0, axios_1.default)(`${__classPrivateFieldGet(this, _StorybookApi_endpoint, "f")}/storybook`, {
                params: {
                    hash,
                },
                method: 'get',
                headers: __classPrivateFieldGet(this, _StorybookApi_getHeaders, "f").call(this, token),
                validateStatus: function (status) {
                    return status < 500;
                },
            });
            if (res.status === 404)
                return null;
            if (res.status !== 200)
                throw new Error('Failed to get Storybook');
            const storybook = res.data;
            return storybook;
        };
        this.updateDSTokenIfNeeded = async ({ currentDSToken, storybook, token, }) => {
            const { ds_tokens, id, upload_status } = storybook;
            const ds_tokensAsString = JSON.stringify(currentDSToken);
            if (ds_tokens !== ds_tokensAsString) {
                try {
                    await this.updateStorybook(token, id, {
                        ds_tokens: ds_tokensAsString,
                        upload_status,
                    });
                }
                catch (e) {
                    throw new Error('Network request failed, response status !== 200');
                }
            }
        };
        this.createStorybook = async (token, params) => {
            const res = await (0, axios_1.default)(`${__classPrivateFieldGet(this, _StorybookApi_endpoint, "f")}/storybook`, {
                method: 'post',
                headers: __classPrivateFieldGet(this, _StorybookApi_getHeaders, "f").call(this, token),
                data: params,
            });
            if (res.status === 200) {
                return res.data;
            }
            return null;
        };
        this.getMostRecentStorybook = async (token) => {
            const query = new URLSearchParams({
                order_by: '-updated_at',
                limit: '1',
            });
            const headers = {
                'Content-Type': 'application/json',
                Authorization: 'Bearer ' + token,
            };
            const res = await (0, axios_1.default)(`${__classPrivateFieldGet(this, _StorybookApi_endpoint, "f")}/storybooks`, {
                params: query,
                method: 'get',
                headers,
            });
            if (!res.data.results.length)
                return null;
            return res.data.results[0];
        };
        this.updateStorybook = async (token, id, fields) => {
            const res = await (0, axios_1.default)(`${__classPrivateFieldGet(this, _StorybookApi_endpoint, "f")}/storybook/${id}`, {
                method: 'put',
                headers: __classPrivateFieldGet(this, _StorybookApi_getHeaders, "f").call(this, token),
                data: fields,
            });
            return res.data;
        };
        this.getOrCreateStorybook = async (token, hash, raw_ds_tokens = {}, basePath) => {
            let storybook = await this.getStorybookByHash(token, hash);
            if (storybook == null) {
                storybook = await this.createStorybook(token, {
                    storybook_hash: hash,
                    ds_tokens: JSON.stringify(raw_ds_tokens),
                    base_path: basePath,
                });
            }
            const { id, upload_signed_url, upload_status = 'init', ds_tokens: dsTokens, } = storybook ?? {};
            return {
                storybookId: id,
                uploadUrl: upload_signed_url,
                uploadStatus: upload_status,
                hash,
                designTokens: dsTokens,
            };
        };
        this.getOrCreateStorybookForDesignTokens = async (token, raw_ds_tokens = {}) => {
            try {
                const storybook = await this.getMostRecentStorybook(token);
                let data = null;
                if (storybook) {
                    data = storybook;
                }
                else {
                    // Not a good solution for hashing, we probably need to separate DS from storybook
                    const hash = (0, hash_1.hashString)(token);
                    data = await this.createStorybook(token, {
                        ds_tokens: JSON.stringify(raw_ds_tokens),
                        storybook_hash: hash,
                        status: 'ready',
                        upload_status: 'complete',
                    });
                }
                const { id, upload_signed_url, upload_status = 'complete', ds_tokens: dsTokens, storybook_hash = '', } = data ?? {};
                return {
                    storybookId: id,
                    uploadUrl: upload_signed_url,
                    uploadStatus: upload_status,
                    hash: storybook_hash,
                    designTokens: dsTokens,
                };
            }
            catch (e) {
                throw new Error('We had an issue making a request to our server. Please try again, or reach out to the Anima team if the problem persists');
            }
        };
        _StorybookApi_getHeaders.set(this, (token) => {
            const headers = {
                'Content-Type': 'application/json',
                Authorization: 'Bearer ' + token,
                ...__classPrivateFieldGet(this, _StorybookApi_addionalHeaders, "f").call(this),
            };
            return headers;
        });
        this.syncOnlyDesignTokens = async (token, designTokens) => {
            const storybook = await this.getOrCreateStorybookForDesignTokens(token, designTokens);
            const storybookId = storybook.storybookId;
            const uploadStatus = storybook.uploadStatus;
            if (storybookId) {
                await this.updateDSTokenIfNeeded({
                    storybook: {
                        id: storybookId,
                        ds_tokens: storybook.designTokens,
                        upload_status: uploadStatus,
                    },
                    token,
                    currentDSToken: designTokens,
                });
            }
            return storybook;
        };
        const { storybookEndpoint, addionalHeaders } = opts;
        __classPrivateFieldSet(this, _StorybookApi_endpoint, storybookEndpoint, "f");
        __classPrivateFieldSet(this, _StorybookApi_addionalHeaders, addionalHeaders, "f");
    }
}
exports.StorybookApi = StorybookApi;
_StorybookApi_endpoint = new WeakMap(), _StorybookApi_addionalHeaders = new WeakMap(), _StorybookApi_getHeaders = new WeakMap();
