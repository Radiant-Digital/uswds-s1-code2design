"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateStories = exports.getTypeImports = exports.extractComponentInformation = exports.getTypes = exports.hasStorybook = exports.getJSFiles = exports.initialiseStorybook = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const debug_1 = require("./debug");
const api_1 = require("../constants/api");
const child_process_1 = require("child_process");
const node_fetch_1 = __importDefault(require("node-fetch"));
const JS_EXTENSIONS = ['js', 'jsx', 'ts', 'tsx', 'vue'];
const STORYBOOK_EXTENSIONS = ['js', 'jsx', 'ts', 'tsx'];
const initialiseStorybook = () => {
    const sampleStoriesPath = path_1.default.join('src', 'stories');
    const hadSampleStorybookFolderBefore = fs_1.default.existsSync(sampleStoriesPath);
    (0, child_process_1.execSync)('npx storybook@latest init -y', { stdio: 'inherit' });
    // Delete the examples added by this command
    if (!hadSampleStorybookFolderBefore && fs_1.default.existsSync(sampleStoriesPath)) {
        fs_1.default.rmSync(sampleStoriesPath, { recursive: true, force: true });
    }
};
exports.initialiseStorybook = initialiseStorybook;
const getFiles = (folder, condition) => {
    const files = [];
    for (const item of fs_1.default.readdirSync(folder)) {
        const fullPath = path_1.default.join(folder, item);
        if (fs_1.default.lstatSync(fullPath).isDirectory()) {
            files.push(...getFiles(fullPath, condition));
        }
        else {
            if (condition(item)) {
                files.push(fullPath);
            }
        }
    }
    return files;
};
const getJSFiles = (folder) => {
    const condition = (filename) => {
        const extension = filename.split('.').pop();
        return (extension &&
            JS_EXTENSIONS.includes(extension) &&
            !filename.endsWith(".d.ts") &&
            filename.charAt(0) === filename.charAt(0).toUpperCase());
    };
    return getFiles(folder, condition);
};
exports.getJSFiles = getJSFiles;
const hasStorybook = (files, file) => {
    const componentName = file.split('.')[0];
    const potentialStoryFiles = STORYBOOK_EXTENSIONS.map((ext) => `${componentName}.stories.${ext}`);
    for (const storyFile of potentialStoryFiles) {
        if (files.includes(storyFile)) {
            return true;
        }
    }
    return false;
};
exports.hasStorybook = hasStorybook;
const getTypes = (buildDir) => {
    const typeFileCondition = (filename) => {
        return filename === "types.d.ts";
    };
    if (!buildDir && fs_1.default.existsSync("tsconfig.json")) {
        const tsConfig = JSON.parse(fs_1.default.readFileSync("tsconfig.json", "utf-8"));
        const tsConfigBuildDir = tsConfig.compilerOptions.outDir;
        if (tsConfigBuildDir && fs_1.default.existsSync(tsConfigBuildDir)) {
            buildDir = tsConfigBuildDir;
        }
        else if (tsConfigBuildDir && !fs_1.default.existsSync(tsConfigBuildDir)) {
            throw Error(`tsconfig.json found but build folder ${tsConfigBuildDir} is not. Please cancel & compile your project, or pass your build folder with the -b argument`);
        }
    }
    if (!buildDir) {
        console.error("No build folder passed (-b). Pass this property for the best performance!");
    }
    const types = new Set();
    if (buildDir && fs_1.default.existsSync(buildDir)) {
        const typeFiles = getFiles(buildDir, typeFileCondition);
        for (const typeFile of typeFiles) {
            const content = fs_1.default.readFileSync(typeFile, "utf-8");
            const typeFileTypes = extractTypes(content);
            typeFileTypes.forEach(t => types.add(t));
        }
    }
    else if (buildDir && !fs_1.default.existsSync(buildDir)) {
        throw Error(`Build folder ${buildDir} not found`);
    }
    if (types.size < 100) {
        return types;
    }
    return new Set();
};
exports.getTypes = getTypes;
const extractComponentInformation = async (file, types, token) => {
    const res = await (0, node_fetch_1.default)(`${api_1.API_URL}/rpc/extract_component_data`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            Authorization: 'Bearer ' + token,
        },
        body: JSON.stringify({ code: file, types }),
    });
    if (res.status === 200) {
        const data = await res.json();
        return data;
    }
    else if ((0, debug_1.isDebug)()) {
        console.log('response status =>', res.status);
        console.log('response data =>', await res.text());
    }
    return null;
};
exports.extractComponentInformation = extractComponentInformation;
const generateStorybookConfig = (filename, resp) => {
    const convertPropType = (type) => {
        switch (type) {
            case 'boolean':
                return "{ control: 'boolean' }";
            case 'string':
                return "{ control: 'text' }";
            case 'object':
                return "{ control: 'object' }";
            case 'number':
                return "{ control: 'number' }";
            default:
                if (Array.isArray(type)) {
                    const isNumberArray = type.every(i => !isNaN(i));
                    return `{ control: 'select', options: [${type.map(i => isNumberArray ? i : `'${i}'`)}]}`;
                }
        }
    };
    const componentFilename = path_1.default.parse(filename).base.split('.')[0];
    const componentImport = resp.default_export
        ? resp.component_name
        : `{ ${resp.component_name} }`;
    const importLine = `import ${componentImport} from './${componentFilename}';`;
    const propTypes = !resp.prop_data_types ? resp.props
        .map(({ name, type }) => convertPropType(type) && `    ${name}: ${convertPropType(type)}`)
        .filter((item) => item) : [];
    return `${importLine}

export default {
  title: "Components/${resp.component_name}",
  component: ${resp.component_name},${propTypes.length > 0
        ? `\n  argTypes: {
${propTypes.join(',\n')}
  }`
        : ''}
};

export const Default = {
  // Add default args here
};
`;
};
const extractImports = (source) => {
    const importRegex = /import\s+([\w{},\s]+)\s+from\s+['"]([^'"]+)['"]/g;
    const imports = [];
    let match;
    while ((match = importRegex.exec(source)) !== null) {
        const importSpecifier = match[1].replace(/[{}\s]/g, '').split(',').filter(i => i);
        const importPath = match[2];
        imports.push({ specifiers: importSpecifier, path: importPath });
    }
    return imports;
};
const findJSFile = (importPath) => {
    for (const extension of JS_EXTENSIONS) {
        const fullPath = `${importPath}.${extension}`;
        if (fs_1.default.existsSync(fullPath)) {
            return fullPath;
        }
    }
    const indexPath = `${importPath}/index.ts`;
    if (fs_1.default.existsSync(indexPath)) {
        return indexPath;
    }
};
const getImportAliases = () => {
    if (fs_1.default.existsSync("tsconfig.json")) {
        const tsConfig = JSON.parse(fs_1.default.readFileSync("tsconfig.json", "utf-8"));
        const tsConfigPaths = tsConfig.compilerOptions.paths || [];
        return Object.entries(tsConfigPaths).map(([k, v]) => ({ [k]: v[0] })).reduce((r, c) => ({ ...r, ...c }), {});
    }
    return {};
};
const extractTypes = (source) => {
    const interfaceRegex = /interface\s+(\w+[\w\s<>?=]*)\s*{([^}]*)}/g;
    const interfaceMatches = source.match(interfaceRegex) || [];
    const interfaces = interfaceMatches.map(match => match.trim());
    const typeRegex = /type\s+([\w]+)\s*=\s*([^;{}]+(?:{[^}]+})?)/g;
    const typeMatches = source.match(typeRegex) || [];
    const types = typeMatches.map(match => match.trim());
    return types.concat(interfaces);
};
const getTypeImports = (content, filePath) => {
    const typeImports = new Set();
    const importAliases = getImportAliases();
    const currentDirectory = path_1.default.dirname(filePath);
    const imports = extractImports(content);
    const relativeImports = imports.filter(i => i.path.startsWith("./") || i.path.startsWith("../") || i.path.startsWith("@") && Object.keys(importAliases).includes(i.path));
    for (const { specifiers, path: relativePath } of relativeImports) {
        let importPath;
        if (relativePath.startsWith("@")) {
            importPath = path_1.default.resolve(importAliases[relativePath]);
        }
        else {
            importPath = path_1.default.resolve(currentDirectory, relativePath);
        }
        const jsFile = findJSFile(importPath);
        if (jsFile) {
            console.log(jsFile);
            const importContent = fs_1.default.readFileSync(jsFile, 'utf8');
            const importTypes = extractTypes(importContent);
            let importFound = false;
            for (const specifier of specifiers) {
                for (const line of importTypes) {
                    if (line.includes(`type ${specifier}`) || line.includes(`interface ${specifier}`)) {
                        typeImports.add(line);
                        importFound = true;
                    }
                }
            }
            if (importFound) {
                const childTypes = (0, exports.getTypeImports)(importContent, jsFile);
                childTypes.forEach(childType => typeImports.add(childType));
            }
        }
    }
    return typeImports;
};
exports.getTypeImports = getTypeImports;
const generateStories = async (files, buildTypes, token) => {
    for (const componentFile of files) {
        console.log(`Creating ${componentFile}...`);
        const componentContent = fs_1.default.readFileSync(componentFile, 'utf8');
        const importTypes = (0, exports.getTypeImports)(componentContent, componentFile);
        const allTypes = Array.from(new Set([...buildTypes, ...importTypes])).join("\n");
        if ((0, debug_1.isDebug)()) {
            fs_1.default.writeFileSync(`${componentFile.split('.')[0]}.types.txt`, allTypes);
        }
        const start = Date.now();
        const response = await (0, exports.extractComponentInformation)(componentContent, allTypes, token).catch((e) => {
            throw e;
        });
        const end = Date.now();
        if ((0, debug_1.isDebug)()) {
            console.log(`Component information time: ${end - start} ms`);
        }
        if (response) {
            if ((0, debug_1.isDebug)()) {
                fs_1.default.writeFileSync(`${componentFile.split('.')[0]}.stories.log.json`, JSON.stringify(response));
            }
            const storybookConfig = generateStorybookConfig(componentFile, response);
            const storyFile = `${componentFile.split('.')[0]}.stories.js`;
            fs_1.default.writeFileSync(storyFile, storybookConfig);
            console.log(`Created ${storyFile}`);
        }
        else {
            console.log(`Skipped ${componentFile}. Couldn't generate story config`);
        }
    }
};
exports.generateStories = generateStories;
