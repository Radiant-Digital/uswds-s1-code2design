"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDesignTokens = exports.DesignTokenError = exports.getFileOrThrow = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const node_1 = require("@sentry/node");
const getFileOrThrow = async (path) => {
    if (path) {
        if (fs_extra_1.default.existsSync(path)) {
            return await fs_extra_1.default.readJSON(path);
        }
        else {
            throw new Error('Path not found');
        }
    }
};
exports.getFileOrThrow = getFileOrThrow;
class DesignTokenError extends Error {
    constructor(message, designTokenFilePath) {
        super('[DesignTokenError]: ' + message);
        this.designTokenFilePath = designTokenFilePath;
    }
}
exports.DesignTokenError = DesignTokenError;
const getDesignTokens = async (designTokenFilePath, animaConfig) => {
    const transaction = (0, node_1.getCurrentHub)().getScope()?.getTransaction();
    const spanGetDSToken = transaction?.startChild({ op: 'get-ds-token' });
    let designTokens = animaConfig.design_tokens ?? {};
    if (designTokenFilePath) {
        if (fs_extra_1.default.existsSync(designTokenFilePath)) {
            designTokens = await fs_extra_1.default.readJSON(designTokenFilePath);
        }
        else {
            spanGetDSToken?.finish();
            throw new DesignTokenError('Path not found', designTokenFilePath);
        }
    }
    spanGetDSToken?.finish();
    return designTokens;
};
exports.getDesignTokens = getDesignTokens;
