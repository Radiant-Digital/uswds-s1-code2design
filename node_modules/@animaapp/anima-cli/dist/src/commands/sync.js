"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = exports.builder = exports.desc = exports.command = void 0;
const config_1 = require("./../helpers/config");
const fs_extra_1 = __importDefault(require("fs-extra"));
const build_1 = require("../helpers/build");
const exit_1 = require("../helpers/exit");
const api_1 = require("../api");
const helpers_1 = require("../helpers");
const Sentry = __importStar(require("@sentry/node"));
const waitAllProcessingStories_1 = require("../helpers/waitAllProcessingStories");
const constants_1 = require("../constants");
const s3_1 = require("../helpers/s3");
const token_1 = require("../helpers/token");
const debug_1 = require("../helpers/debug");
const loader_1 = require("../helpers/loader");
const file_system_1 = require("../helpers/file-system");
const handleError_1 = require("../handleError");
const analytics_1 = require("../helpers/analytics");
const storybook_1 = require("../api/storybook");
exports.command = 'sync';
exports.desc = 'Sync Storybook to Figma using Anima';
const builder = (yargs) => yargs
    .options({
    token: { type: 'string', alias: 't' },
    storybook: {
        alias: 's',
        coerce: (arg) => {
            if (arg === true) {
                return 'storybook-static'; // Set a default value if it's a boolean
            }
            else {
                return arg; // Return the string argument value
            }
        },
    },
    basePath: { type: 'string', alias: 'b' },
    designTokens: { type: 'string', alias: 'd' },
    debug: { type: 'boolean' },
})
    .check((argv) => {
    if (!argv.storybook && !argv['design-tokens']) {
        throw new Error('At least one design-tokens or storybook must be set.');
    }
    return true;
})
    .example([['$0 sync -t <storybook-token> -s <storybook-build-dir>']]);
exports.builder = builder;
const handler = async (_argv) => {
    const transaction = Sentry.startTransaction({
        op: 'start-sync',
        name: 'start sync process',
    });
    try {
        Sentry.getCurrentHub().configureScope((scope) => scope.setSpan(transaction));
        (0, debug_1.setDebug)(!!_argv.debug);
        if ((0, debug_1.isDebug)()) {
            (0, analytics_1.setEnableTracking)(false);
        }
        const animaConfig = await (0, config_1.loadAnimaConfig)();
        loader_1.loader.newStage('Checking local environment');
        // validate token with the api
        const token = (0, token_1.getToken)(_argv);
        const response = await (0, api_1.authenticate)(token);
        const teamId = response.data.team_id;
        const ownerId = response.data.team_owner_id;
        Sentry.configureScope((scope) => {
            scope.setUser({
                id: ownerId,
                team_id: teamId,
            });
            scope.setTag('teamId', response.data.team_id);
        });
        if (_argv.storybook) {
            const buildDir = await (0, build_1.parseBuildDirArg)(_argv.storybook);
            (0, build_1.validateBuildDir)(buildDir);
            // zip the build directory and create a hash
            loader_1.loader.newStage('Preparing files');
            const { zipHash, zipBuffer } = await (0, helpers_1.generateZipHash)(buildDir);
            loader_1.loader.newStage('Syncing files');
            const designTokens = await (0, file_system_1.getDesignTokens)(_argv.designTokens, animaConfig);
            const basePath = _argv.basePath;
            const { storybookId, uploadUrl, ...data } = await storybook_1.storybookApi.getOrCreateStorybook(token, zipHash, designTokens, basePath);
            (0, analytics_1.trackEvent)([
                {
                    userID: ownerId,
                    action: 'anima-cli.sync.started',
                    time: Date.now(),
                    eventParams: {
                        platform: 'anima-cli',
                        utm_source: 'anima-cli',
                        team_id: teamId,
                    },
                },
            ]);
            const { skipUpload, uploadStatus } = await (0, helpers_1.uploadStorybook)({
                zipBuffer: zipBuffer,
                storybookId,
                token,
                uploadUrl,
                uploadStatus: data.uploadStatus,
            });
            // create storybook object if no record with the same hash is found and upload it
            const currentDesignTokenStr = data.designTokens;
            if (storybookId && uploadStatus === 'complete') {
                await storybook_1.storybookApi
                    .updateDSTokenIfNeeded({
                    storybook: {
                        id: storybookId,
                        ds_tokens: currentDesignTokenStr,
                        upload_status: uploadStatus,
                    },
                    token,
                    currentDSToken: designTokens,
                })
                    .catch((e) => {
                    Sentry.captureException(e);
                    helpers_1.log.yellow(`Failed to update designTokens, ${e.message}`);
                });
            }
            if ((0, debug_1.isDebug)()) {
                console.log('_id =>', storybookId);
                console.log('hash =>', zipHash);
                console.log('SkipUpload => ', skipUpload);
            }
            loader_1.loader.newStage('Processing stories');
            const waitProcessSpan = transaction.startChild({
                op: 'waitProcessingStories',
            });
            // --- Start wait sync
            await (0, waitAllProcessingStories_1.waitProcessingStories)(token, {
                onCheckStories: (stories) => {
                    const stage = stories.length > 0
                        ? `Processing stories: ${stories.length} remaining`
                        : 'Processing stories';
                    loader_1.loader.newStage(stage, false);
                },
            });
            loader_1.loader.stop();
            waitProcessSpan.finish();
            // --- Cleaning and goodbye ---
            transaction.status = 'ok';
            transaction.finish();
            helpers_1.log.green(`  - Processing stories ... OK`);
        }
        else {
            loader_1.loader.newStage('Syncing design tokens');
            const designTokens = await (0, file_system_1.getDesignTokens)(_argv.designTokens, animaConfig);
            const storybook = await storybook_1.storybookApi
                .syncOnlyDesignTokens(token, designTokens)
                .catch((e) => {
                Sentry.captureException(e);
                helpers_1.log.yellow(`Failed to update designTokens, ${e.message} \n`);
            });
            (0, analytics_1.trackEvent)([
                {
                    userID: ownerId,
                    action: 'anima-cli.sync.only-tokens.started',
                    time: Date.now(),
                    eventParams: {
                        platform: 'anima-cli',
                        utm_source: 'anima-cli',
                        team_id: teamId,
                    },
                },
            ]);
            if ((0, debug_1.isDebug)()) {
                console.log('_id =>', storybook?.storybookId);
                console.log('hash =>', storybook?.hash);
            }
            loader_1.loader.stop();
        }
        helpers_1.log.green('  - Done');
        if ((0, s3_1.isUsingS3Url)()) {
            console.log('Cleaning tmp dir');
            fs_extra_1.default.rmSync(constants_1.TMP_DIR, { recursive: true, force: true });
        }
    }
    catch (e) {
        if (e instanceof Error) {
            (0, handleError_1.handleError)(e);
        }
        transaction.status = 'error';
        transaction.finish();
        await (0, exit_1.exitProcess)();
    }
};
exports.handler = handler;
