"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.showStory = exports.getStories = void 0;
const p_timeout_1 = __importDefault(require("p-timeout"));
const ts_dedent_1 = __importDefault(require("ts-dedent"));
/**
 * Get the list of stories from a static storybook build.
 */
function getStories(page) {
    return __awaiter(this, void 0, void 0, function* () {
        const rawStories = yield (0, p_timeout_1.default)(page.evaluate(fetchStoriesFromWindow), 10000).catch((e) => {
            throw new Error((0, ts_dedent_1.default) `
      Stories could not be retrieved from storybook!

      Please check that...
      - You're using a compatible version of Storybook
      - Storybook doesn't have any errors

      Otherwise this is likely a bug with axe-storybook-testing.

      Original error message: ${e}
    `);
        });
        return rawStories;
    });
}
exports.getStories = getStories;
/**
 * Render a story on a Storybook page.
 */
function showStory(page, id) {
    return __awaiter(this, void 0, void 0, function* () {
        yield page.evaluate(emitSetCurrentStory, id);
    });
}
exports.showStory = showStory;
/**
 * Get a list of stories from Storybook's internal API.
 *
 * Executes in a browser context.
 */
function fetchStoriesFromWindow() {
    const storybookPreview = window.__STORYBOOK_PREVIEW__;
    const storyStore = storybookPreview.storyStore;
    return storyStore.cacheAllCSFFiles().then(() => {
        // Pick only the properties we need from Storybook's representation of a story.
        //
        // This is necessary because Playwright's `page.evaluate` requires return values to be JSON
        // serializable, so we need to make sure there are no non-serializable things in this object.
        // There's no telling what Storybook addons people are using, and whether their parameters are
        // serializable or not.
        //
        // See https://github.com/chanzuckerberg/axe-storybook-testing/issues/44 for a bug caused by this.
        function pickOnlyNecessaryAndSerializableStoryProperties(story) {
            return {
                id: story.id,
                name: story.name,
                kind: story.kind,
                parameters: {
                    axe: story.parameters.axe,
                },
            };
        }
        return storyStore
            .raw()
            .map(pickOnlyNecessaryAndSerializableStoryProperties);
    });
}
/**
 * Abuse Storybook's internal APIs to render a story without requiring a page reload (which would
 * be slow).
 *
 * Doing so is brittle, and updates to Storybook could break this. The trade off is that we don't
 * have to figure out how to process stories with Webpack - Storybook handles that for us.
 *
 * Executes in a browser context.
 */
function emitSetCurrentStory(id) {
    const storybookPreview = window.__STORYBOOK_PREVIEW__;
    if (!storybookPreview) {
        return Promise.reject(new Error("Storybook doesn't seem to be running on the page"));
    }
    storybookPreview.channel.emit('setCurrentStory', {
        storyId: id,
        viewMode: 'story',
        options: {
            target: 'storybook-preview-iframe',
        },
    });
    return new Promise((resolve) => {
        storybookPreview.channel.once('storyRendered', resolve);
    });
}
