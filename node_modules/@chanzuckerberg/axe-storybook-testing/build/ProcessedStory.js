"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const zod_1 = require("zod");
/**
 * Story with normalized and custom properties needed by this project.
 */
class ProcessedStory {
    constructor(rawStory) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        this.name = rawStory.name;
        this.componentTitle = rawStory.kind;
        this.id = rawStory.id;
        this.parameters = {
            skip: normalizeSkip((_b = (_a = rawStory.parameters) === null || _a === void 0 ? void 0 : _a.axe) === null || _b === void 0 ? void 0 : _b.skip, rawStory),
            disabledRules: normalizeDisabledRules((_d = (_c = rawStory.parameters) === null || _c === void 0 ? void 0 : _c.axe) === null || _d === void 0 ? void 0 : _d.disabledRules, rawStory),
            mode: normalizeMode((_f = (_e = rawStory.parameters) === null || _e === void 0 ? void 0 : _e.axe) === null || _f === void 0 ? void 0 : _f.mode, rawStory),
            waitForSelector: normalizeWaitForSelector((_h = (_g = rawStory.parameters) === null || _g === void 0 ? void 0 : _g.axe) === null || _h === void 0 ? void 0 : _h.waitForSelector, rawStory),
            timeout: normalizeTimeout((_k = (_j = rawStory.parameters) === null || _j === void 0 ? void 0 : _j.axe) === null || _k === void 0 ? void 0 : _k.timeout, rawStory),
            runOptions: normalizeRunOptions((_m = (_l = rawStory.parameters) === null || _l === void 0 ? void 0 : _l.axe) === null || _m === void 0 ? void 0 : _m.runOptions, rawStory),
        };
    }
    /**
     * Run option for rules to disable in a given story
     */
    get disabledRules() {
        return this.parameters.disabledRules;
    }
    /**
     * Whether axe should even run on this story or not.
     */
    get shouldNotEvenRunTest() {
        return this.parameters.mode === 'off' || this.parameters.skip;
    }
    /**
     * Whether axe violations should cause the test suite to fail or not.
     */
    get shouldFailTestSuiteIfViolations() {
        return this.parameters.mode === 'error';
    }
    /**
     * All optional run options used for a given story
     * @see https://www.deque.com/axe/core-documentation/api-documentation/#options-parameter
     */
    get runOptions() {
        return this.parameters.runOptions;
    }
    /**
     * Timeout override for a test triggered in runSuite()
     */
    get timeout() {
        return this.parameters.timeout;
    }
    /** @deprecated */
    get waitForSelector() {
        return this.parameters.waitForSelector;
    }
}
exports.default = ProcessedStory;
const disabledRulesSchema = zod_1.z.array(zod_1.z.string()).optional();
const modeSchema = zod_1.z.enum(['off', 'warn', 'error']).optional();
const skipSchema = zod_1.z.boolean().optional();
const timeoutSchema = zod_1.z.number().gte(0).optional();
const waitForSelectorSchema = zod_1.z.string().optional();
const runOptionsSchema = zod_1.z.optional(zod_1.z.object({
    runOnly: zod_1.z.optional(zod_1.z.object({
        type: zod_1.z.enum(['rule', 'rules', 'tag', 'tags']),
        values: zod_1.z.array(zod_1.z.string()),
    })),
    rules: zod_1.z.optional(zod_1.z.object({}).catchall(zod_1.z.object({
        enabled: zod_1.z.boolean(),
    }))),
    reporter: zod_1.z.optional(zod_1.z.enum(['v1', 'v2', 'raw', 'raw-env', 'no-passes'])),
    resultTypes: zod_1.z.optional(zod_1.z.array(zod_1.z.enum(['inapplicable', 'passes', 'incomplete', 'violations']))),
    selector: zod_1.z.optional(zod_1.z.boolean()),
    ancestry: zod_1.z.optional(zod_1.z.boolean()),
    xpath: zod_1.z.optional(zod_1.z.boolean()),
    absolutePaths: zod_1.z.optional(zod_1.z.boolean()),
    iframes: zod_1.z.optional(zod_1.z.boolean()),
    elementRef: zod_1.z.optional(zod_1.z.boolean()),
    frameWaitTime: zod_1.z.optional(zod_1.z.number().gte(0)),
    preload: zod_1.z.optional(zod_1.z.boolean()),
    performanceTimer: zod_1.z.optional(zod_1.z.boolean()),
    pingWaitTime: zod_1.z.optional(zod_1.z.number().gte(0)),
}));
function normalizeSkip(skip, rawStory) {
    return parseWithFriendlyError(() => skipSchema.parse(skip) || false, rawStory, 'skip');
}
function normalizeDisabledRules(disabledRules, rawStory) {
    return parseWithFriendlyError(() => disabledRulesSchema.parse(disabledRules) || [], rawStory, 'disabledRules');
}
function normalizeTimeout(timeout, rawStory) {
    return parseWithFriendlyError(() => timeoutSchema.parse(timeout) || 0, rawStory, 'timeout');
}
function normalizeRunOptions(runOptions, rawStory) {
    return parseWithFriendlyError(() => runOptionsSchema.parse(runOptions) || {}, rawStory, 'runOptions');
}
function normalizeWaitForSelector(waitForSelector, rawStory) {
    return parseWithFriendlyError(() => waitForSelectorSchema.parse(waitForSelector), rawStory, 'waitForSelector');
}
function normalizeMode(mode, rawStory) {
    return parseWithFriendlyError(() => modeSchema.parse(mode) || 'error', rawStory, 'mode');
}
/**
 * Our Parameter parsers use Zod under the hood, which works great. Unfortunately, there's no way
 * to provide a custom error message when parsing, and its default error messages won't give users
 * enough information about what went wrong and where. Instead we'll catch errors from the parsers
 * and re-throw our own.
 */
function parseWithFriendlyError(parser, rawStory, paramName) {
    try {
        return parser();
    }
    catch (message) {
        if (message instanceof zod_1.z.ZodError) {
            throw new TypeError(`Invalid value for parameter "${paramName}" in component "${rawStory.kind}", story "${rawStory.name}"`);
        }
        else {
            throw message;
        }
    }
}
